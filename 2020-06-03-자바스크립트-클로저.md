# closure #

> 클로저는 함수와 함수가 선언됐을 때의 렉시컬 환경과의 조합이다. - MDN
<br />

외부함수 안의 내부함수가 실행되고 메모리 상에서 정리되었어야 할 외부함수의 맥락을 내부함수가 기억하고 있는 것이다.

```js
var x = 'sunny';
function outerFunc() {
  var x = 'sally';
  function innerFunc() {
    console.log(x);
  }
  return innerFunc;
}
  const outer = outerFunc();
  // sally
```

전역변수 x가 sunny로 선언되어 있는 상태이고 outerFunc은 호출되며 innerFunc을 리턴하고 콜스택에서 정리되었다. 
지역변수 x가 스택에서 정리되어 더이상 이에 접근 불가능 할 것처럼 보이지만 콘솔창에는 sally가 찍힌다. <br /><br />

위의 코드에서 outerFunc은 innerFunc을 리턴하며 정리되었고 innerFunc이 더 오래 유지되고 있다. <br />

내부함수를 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되고 있는 경우 
외부함수 밖에서 내부함수가 호출되더라도 외부함수의 지역변수에 접근할 수 있다.
내부함수가 자신이 생성될 때의 렉시컬 환경을 기억하기 때문이다.

그래서 콜솔 창에는 sally가 찍히게 되는 것이다. <br />

### 클로저를 사용하는 이유? ###
여러 장점이 있을 수 있겠으나 클로저를 사용하는 가장 큰 이유는 **전역변수 사용 최소화** 및 **정보은닉** 정도가 될 것 같다.
코드상에 언제든지 누구나 접근 가능한 전역변수가 난무하다면 
개발자가 언제 어떻게 전역변수를 건드려 사이드 이펙트를 발생시킬지 모를일이다. <br /><br />

관련있는 변수와 메소드를 하나의 틀 안에 담고 외부에 공개될 필요가 없는 정보는 숨기게 되면
원하지 않은 접근으로부터 내부를 보호할 수 있게 되고 사이드 이펙트를 줄일 수 있을 것이다.
그 틀은 클래스가 될 수도 있고 클로저도 될 수 있다. <br /><br />


_[참고] poiema web_


